> åŸæ–‡é“¾æ¥: https://fasterthanli.me/articles/a-half-hour-to-learn-rust
> 
> ç¿»è¯‘ï¼š[Asura](https://github.com/asur4s)
> 
> é€‰é¢˜ï¼š[Asura](https://github.com/asur4s)
>
> æœ¬æ–‡ç”± [Rustt](https://Rustt.org) ç¿»è¯‘ï¼Œ[StudyRust](https://studyrust.org) è£èª‰æ¨å‡º

# åŠå°æ—¶å¿«é€Ÿäº†è§£ Rust

é€šè¿‡å¤§é‡çš„é˜…è¯»ä»£ç ï¼Œèƒ½å¢å¼ºæˆ‘ä»¬å¯¹ç¼–ç¨‹è¯­è¨€çš„ç†Ÿç»ƒåº¦ã€‚ä½†å¦‚æœä½ ä¸çŸ¥é“ä»£ç çš„èƒŒåå«ä¹‰ï¼Œå¤§é‡é˜…è¯»åˆæ€èƒ½è·å¾—æ”¶ç›Šå‘¢ï¼Ÿ

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œä¸æ˜¯ä¸“æ³¨äº Rust ä¸­çš„ä¸€ä¸¤ä¸ªæ¦‚å¿µï¼Œè€Œæ˜¯å°½æˆ‘æ‰€èƒ½çš„è¦†ç›– Rust ä»£ç ç‰‡æ®µï¼Œå¹¶è§£é‡Šå…³é”®å­—å’Œç¬¦å·çš„å«ä¹‰ã€‚

å‡†å¤‡å¥½äº†å—ï¼ŸLet's goï¼

## 1 å˜é‡ç»‘å®š

å˜é‡ç»‘å®šçš„æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
let x;      // å£°æ˜å˜é‡ x 
x = 42;     // å°† 42 ç»‘å®šåˆ° xã€‚Rust ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨å¯¼æ­¤å¤„ x çš„ç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ä¸ç”¨å£°æ˜ç±»å‹ã€‚
// å˜é‡ç»‘å®šæ˜¯ä¸å¯å˜çš„ï¼ˆåœ¨ç¬¬ 9 å°èŠ‚ä¼šç»§ç»­æ¢è®¨ï¼‰
```
ä¸Šé¢çš„ä»£ç ä¹Ÿèƒ½å†™æˆä¸€è¡Œï¼š
```rust
let x = 42;
```

è¿˜å¯ä»¥é€šè¿‡å†’å· `:` æ¥æ˜¾å¼çš„æŒ‡å®šå˜é‡ç±»å‹ï¼š
```rust
let x: i32; // i32 è¡¨ç¤º 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°
x = 42;

// æœ‰ç¬¦å·æ•´å‹åŒ…æ‹¬ï¼ši8, i16, i32, i64, i128
// æ— ç¬¦å·æ•´å‹åŒ…æ‹¬ï¼šu8, u16, u32, u64, u128 
```

ç¼–è¯‘å™¨ä¸å…è®¸åœ¨åˆå§‹åŒ–å˜é‡å‰ä½¿ç”¨å®ƒï¼š
```rust
let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x` 
x = 42;
```

å†™æˆä¸‹é¢è¿™æ ·å°±èƒ½æ­£å¸¸è¿è¡Œäº†ï¼š
```rust
let x;
x = 42;
foobar(x);
```

ä¸‹åˆ’çº¿ `_` æ˜¯ Rust ä¸­çš„ä¿ç•™æ ‡è¯†ç¬¦ã€‚åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡æœ‰ä¸åŒçš„ç”¨é€”ï¼Œé€šå¸¸æ„å‘³ç€æŸäº›ä¸œè¥¿è¢«å¿½ç•¥ã€‚å¯ä»¥ç”¨äºä¸¢å¼ƒå˜é‡å€¼ï¼Œè¿˜å¯ä»¥ç”¨äºè¡¨ç¤ºä»»æ„ï¼ˆåœ¨ match éƒ¨åˆ†ä¼šè®²åˆ°ï¼‰ã€‚
```rust
// 42 æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œ_ ä¼šä¸¢å¼ƒèµ‹ç»™å®ƒçš„å€¼ã€‚
let _ = 42;

// è¿™é‡Œè¡¨ç¤ºä¸¢å¼ƒ get_thing å‡½æ•°çš„ä»»ä½•è¿”å›ç»“æœã€‚
let _ = get_thing();
```

å˜é‡å¯ä»¥ç”¨ä¸‹åˆ’çº¿å¼€å¤´ï¼Œå®ƒçš„ä½œç”¨çš„å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œå³ä½¿è¯¥å˜é‡æœªè¢«ä½¿ç”¨ä¹Ÿä¸è¦è­¦å‘Šã€‚
```rust
let _x = 42;
```

åŒä¸€ä¸ªå˜é‡åå¯ä»¥è¢«å¤šæ¬¡ç»‘å®šï¼Œåé¢çš„ç»‘å®šä¼šè¦†ç›–å‰é¢çš„ç»‘å®šã€‚
```rust
let x = 13;
let x = 3.5;    // å‰é¢çš„ x å˜é‡å›æ”¶ï¼Œx é‡æ–°æŒ‡å‘æ–°çš„åœ°å€ã€‚
// é€šè¿‡é‡æ–°ç»‘å®šå˜é‡ï¼Œå¯ä»¥æ”¹å˜å˜é‡çš„ç±»å‹ã€‚
```

## 2ã€å…ƒç»„

Rust ä¸­æœ‰ä¸€ç§æ•°æ®ç»“æ„å«åšå…ƒç»„ï¼Œä½ å¯ä»¥æŠŠå®ƒè®¤ä¸ºæ˜¯é•¿åº¦å›ºå®šçš„ã€å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹å€¼çš„å®¹å™¨ã€‚
```rust
let pair = ('a', 17);
pair.0; // ç”¨äºè¡¨ç¤º 'a'
pair.1; // ç”¨äºè¡¨ç¤º 17
```

æ ‡æ³¨å˜é‡çš„æ•°æ®ç±»å‹ä¸ºå…ƒç»„ï¼š
```rust
let pair: (char, i32) = ('a', 17)
```

èµ‹å€¼è¯­å¥å¯ä»¥å°†å…ƒç»„è¿›è¡Œè§£æ„ã€‚ä¹Ÿå°±æ˜¯ï¼ŒæŠŠå…ƒç»„ä¸­çš„å€¼æ‹†åˆ†åˆ°ä¸åŒçš„å˜é‡ä¸­ã€‚
```rust
let (some_char, some_int) = ('a', 17);
// some_char è¢«èµ‹å€¼ä¸º 'a'ï¼Œsome_int è¢«èµ‹å€¼ä¸º 17
```

å½“å‡½æ•°è¿”å›å…ƒç»„æ—¶ï¼Œåˆ©ç”¨èµ‹å€¼è¯­å¥æ¥è§£æ„æ˜¯éå¸¸æ–¹ä¾¿çš„ã€‚
```rust
let (left, right) = slice.split_at(middle);
```

åœ¨è§£æ„å…ƒç»„æ—¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ `_` æ¥ä¸¢å¼ƒæ‰æŸäº›éƒ¨åˆ†ã€‚
```rust
let (_, right) = slice.split_at(middle);
```

## 3ã€è¯­å¥

åˆ†å· `;` æ ‡æ³¨ä¸€æ¡è¯­å¥çš„ç»“æŸã€‚
```rust
let x = 3;
let y = 5;
let z = y + x;
```

è¿™æ„å‘³ç€ä¸€æ¡è¯­å¥å¯ä»¥è·¨è¶Šå¤šè¡Œã€‚
```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```
æ–‡ç« åç»­ä¼šè§£é‡Šä¸Šè¿°è¯­å¥çš„å«ä¹‰ã€‚

## 4ã€å‡½æ•°ä¸ä»£ç å—

å…³é”®å­— `fn` å¯ä»¥ç”¨äºå£°æ˜å‡½æ•°ï¼Œä¸‹é¢å£°æ˜äº†ä¸€ä¸ªæ— è¿”å›å€¼çš„å‡½æ•°ã€‚
```rust
fn greet() {
    println!("Hi there!");
}
```

å£°æ˜ä¸€ä¸ªè¿”å›å€¼ç±»å‹æ˜¯ i32 çš„å‡½æ•°ï¼Œç®­å¤´å¯ä»¥ç”¨äºæ ‡æ³¨è¿”å›å€¼ç±»å‹ã€‚
```rust
fn fair_dice_roll() -> i32 {
    4
}
```

å¤§æ‹¬å·è¡¨ç¤ºä»£ç å—ï¼Œä»£ç å—æœ‰è‡ªå·±çš„ä½œç”¨åŸŸï¼ˆåé¢ç®€ç§°â€œå—â€ï¼‰ã€‚
```rust
fn main() {
    let x = "out";
    {
        // å¦ä¸€ä¸ª x å˜é‡
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
// è¾“å‡ºï¼š
// in
// out
```

å—ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼Œè¿™æ„å‘³ç€ï¼Œå—å¯ä»¥ä½œä¸ºå€¼æ¥ä½¿ç”¨ã€‚
```rust
let x = 42;

// å’Œä¸Šé¢ç­‰ä»·
let x = { 42 };
```

åœ¨å—ä¸­ï¼Œå¯ä»¥æœ‰å¤šæ¡è¯­å¥ã€‚
```rust
let x = {
    let y = 1; // ç¬¬ä¸€æ¡è¯­å¥
    let z = 2; // ç¬¬äºŒæ¡è¯­å¥
    y + z // å—æœ«å°¾ï¼Œå³ä»£ç å—çš„å€¼ã€‚æ³¨æ„æ²¡æœ‰åˆ†å·ã€‚
};
```

å‡½æ•°çš„å—ä¹Ÿæ»¡è¶³ä¸Šè¿°çš„ç‰¹ç‚¹ï¼Œå› æ­¤åœ¨å‡½æ•°æœ«å°¾å¯ä»¥ä¸ä½¿ç”¨ returnï¼Œä¸‹é¢ä¸¤ç§å†™æ³•çš„åŠŸèƒ½æ˜¯ä¸€æ ·çš„ï¼š
```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```

if æ¡ä»¶è¯­å¥ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼š
```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

match è¯­å¥ä¹Ÿæ˜¯è¡¨è¾¾å¼ï¼š
```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}

```

## 5ã€æ“ä½œç¬¦ä¸å‘½åç©ºé—´

ç‚¹æ“ä½œç¬¦ `.` å¯ä»¥ç”¨äºè®¿é—®å…ƒç»„çš„å€¼ï¼š
```rust
let a = (10, 20);
a.0; // a.0 ä»£è¡¨ a çš„ä¸‹æ ‡ä¸º 0 çš„å…ƒç´ ï¼Œå³ 10ã€‚
```

ç‚¹æ“ä½œç¬¦è¿˜å¯ä»¥è°ƒç”¨æŸä¸ªå˜é‡çš„æ–¹æ³•ï¼š
```rust
let nick = "fasterthanlime";
nick.len(); // å€¼ä¸º 14
```

åŒåˆ†å· `::` å’Œç‚¹æ“ä½œç¬¦ `.` ç±»ä¼¼ï¼Œä¸è¿‡åŒåˆ†å·ç”¨äºå‘½åç©ºé—´ã€‚åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œ`std` æ˜¯ä¸€ä¸ª crateï¼ˆç±»ä¼¼ Python ä¸­åº“ï¼‰ï¼Œ`cmp` æ˜¯åº“é‡Œé¢ä¸€ä¸ªæ¨¡å—ï¼ˆç±»ä¼¼ Python ä¸­çš„ä¸€ä¸ªæºæ–‡ä»¶ï¼‰ï¼Œ`min` æ˜¯æ¨¡å—ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼š
```rust
let least = std::cmp::min(3, 8); // å€¼ä¸º 3
```

`use` æŒ‡ä»¤å¯ä»¥å¼•å…¥å…¶ä»–å‘½åç©ºé—´çš„ç¬¦å·ï¼ˆç±»ä¼¼ Python ä¸­çš„ `import`ï¼‰ã€‚
```rust
use std::cmp::min;

let least = min(7, 1); // å€¼ä¸º 1
```

`use` æŒ‡ä»¤å¯ä»¥å’Œå¤§æ‹¬å·ä¸€èµ·ä½¿ç”¨ã€‚å¦‚æœä½ æƒ³å¼•å…¥ `min` å’Œ `max` ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™äº›æ–¹å¼ï¼š
```rust
// æ–¹æ³• 1ï¼š
use std::cmp::min;
use std::cmp::max;

// æ–¹æ³• 2ï¼š
use std::cmp::{min, max};

// æ–¹æ³• 3ï¼š
use std::{cmp::min, cmp::max};
```

ä½¿ç”¨é€šé…ç¬¦ `*` å¯ä»¥å¼•å…¥è¯¥å‘½åç©ºé—´æ‰€æœ‰çš„ç¬¦å·ã€‚
```rust
// å°†ä¼šå¼•å…¥ cmp ä¸­çš„æ‰€æœ‰ç¬¦å·ï¼ŒåŒ…æ‹¬ minã€max
use std::cmp::*;
```

æ•°æ®ç±»å‹ä¹Ÿæ˜¯ä¸€ç§å‘½åç©ºé—´ï¼Œæ•°æ®ç±»å‹ä¸‹çš„æ–¹æ³•å¯ä»¥ä½œä¸ºå¸¸è§„å‡½æ•°ä½¿ç”¨ã€‚
```rust
let x = "amos".len(); // å€¼ä¸º 4
let x = str::len("amos"); // å€¼ä¸º 4
```

`str` æ˜¯æ¥è‡ªæ ¸å¿ƒè¯­è¨€å±‚é¢çš„åŸºæœ¬ç±»å‹ï¼Œåœ¨ç¨‹åºä¸­ï¼Œè¿˜æœ‰è®¸å¤šéåŸºç¡€ç±»å‹ä¹Ÿè¢«å¼•å…¥åˆ°ä½œç”¨åŸŸä¸­ï¼Œä¾‹å¦‚ `Vec`ã€`String`ã€`Option` å’Œ `Result`ï¼š
```rust
// `Vec` æ˜¯ä¸€ç§å¸¸ç”¨çš„ç»“æ„ä½“ï¼Œä½†ä¸æ˜¯åŸºæœ¬ç±»å‹ã€‚
let v = Vec::new();

// åŒä¸Šï¼Œä½†æ˜¯ä½¿ç”¨äº† `Vec` çš„å…¨è·¯å¾„ã€‚
let v = std::vec::Vec::new();
```

è¿™æ˜¯å› ä¸º Rust åœ¨æ‰€æœ‰æ¨¡å—çš„å¼€å¤´éƒ½æ’å…¥äº†ä¸‹é¢è¿™è¡Œè¯­å¥ï¼š
```rust
use std::prelude::v1::*;
// prelude æ˜¯é¢„å¯¼å…¥æ¨¡å—
```


## 6ã€ç»“æ„ä½“

ç±»ä¼¼ C å’Œ C++ï¼ŒRust ä¸­ä¹Ÿæœ‰ç»“æ„ä½“ï¼š
```rust
struct Vec2 {
    x: f64, // 64 ä½æµ®ç‚¹ç±»å‹ï¼Œå³åŒç²¾åº¦ã€‚
    y: f64,
}
```
å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹æ³•æ¥åˆå§‹åŒ–ç»“æ„ä½“ã€‚
```rust
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// é¡ºåºä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯åç§°ã€‚
```
è¿˜æœ‰ä¸€ç§ç®€å•çš„æ–¹æ³•â€”â€”ä½¿ç”¨å…¶ä»–ç»“æ„ä½“å®ä¾‹æ¥åˆå§‹åŒ–å‰©ä½™çš„å­—æ®µï¼š
```rust
let v3 = Vec2 {
    x: 14.0,
    ..v2        // æ²¡æœ‰é€—å·
};
```
è¿™ç§æ–¹æ³•å«åšç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼Œåªèƒ½æ”¾åœ¨æœ«å°¾éƒ¨åˆ†ï¼Œå¹¶ä¸”åé¢ä¸èƒ½æœ‰é€—å·ã€‚

ç»“æ„ä½“æ›´æ–°è¯­æ³•å¯ä»¥æ›´æ–°å…¨éƒ¨å­—æ®µï¼š
```rust
let v4 = Vec2 { ..v3 };
```

ç±»ä¼¼å…ƒç»„ï¼Œç»“æ„ä½“ä¹Ÿå¯ä»¥è¢«è§£æ„ã€‚åªéœ€è¦åƒä¸‹é¢è¿™æ ·ä½¿ç”¨ `let` å³å¯ï¼š
```rust
let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// Vec2 ä¸­ï¼Œx å€¼ä¸º 3.0, y å€¼ä¸º 6.0
```

è§£æ„ç»“æ„ä½“æ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨ `_` æ¥ä¸¢å¼ƒå­—æ®µï¼š
```rust
let Vec2 { x, .. } = v;
// å°†ä¼šä¸¢å¼ƒ v.y
```

åœ¨ç»“æ„ä½“ä¸­ï¼Œå¦‚æœå­—æ®µçš„åç§°å’Œå˜é‡ç»‘å®šçš„åç§°ç›¸åŒï¼Œå¦‚ä¸‹æ‰€ç¤º
```rust
let p = Person { name: name };
```

å¯ä»¥åƒä¸‹é¢è¿™æ ·ç®€å†™ï¼š
```rust
let p = Person { name };
```

## 7ã€let ä¸ match

`let` å¥å‹å¯ä»¥ä½œä¸º `if` è¯­å¥ä¸­çš„æ¡ä»¶ï¼š
```rust
struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    // å¦‚æœ n ä¸­çš„ odd å­—æ®µä¸º True
    if let Number { odd: true, value } = n {
        println!("Odd number: {}", value);
    } else if let Number { odd: false, value } = n {
        println!("Even number: {}", value);
    }
}

// è¾“å‡ºå¦‚ä¸‹ï¼š
// Odd number: 1
// Even number: 2
```

`match` ä¹Ÿæ˜¯ rust ä¸­çš„å…³é”®å­—ï¼Œç”¨äºåŒ¹é…ã€‚
> å½“ä½ åªè¦åŒ¹é…ä¸€ä¸ªæ¡ä»¶ï¼Œä¸”å¿½ç•¥å…¶ä»–æ¡ä»¶æ—¶å°±ç”¨ `if let` ï¼Œå¦åˆ™éƒ½ç”¨ `match`ã€‚
```rust
fn print_number(n: Number) {
    match n {
        Number { odd: true, value } => println!("Odd number: {}", value),
        Number { odd: false, value } => println!("Even number: {}", value),
    }
}
// è¾“å‡ºç»“æœå’Œä¸Šä¸€ä¸ªä¾‹å­ä¸€æ ·ã€‚
```

`match` åŒ¹é…å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½æ€§ï¼šè¾“å…¥è‡³å°‘èƒ½åŒ¹é…åˆ°ä¸€ä¸ªåˆ†æ”¯ã€‚
```rust
fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } => println!("One"),
        Number { value: 2, .. } => println!("Two"),
        Number { value, .. } => println!("{}", value),
        // å¦‚æœä¸å­˜åœ¨æœ€åä¸€ä¸ªåˆ†æ”¯ï¼Œåœ¨ç¼–è¯‘æ—¶å°±ä¼šæŠ¥é”™ã€‚
    }
}
```

å¦‚æœä¸Šé¢çš„å†™æ³•å¤ªå¤æ‚ï¼Œå¯ä»¥ä½¿ç”¨ `_` æ¥ä»£æ›¿ã€‚`_` å¯ä»¥ç”¨äºåŒ¹é…ä»»æ„è¾“å…¥ã€‚
```rust
fn print_number(n: Number) {
    match n.value {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("{}", n.value),
    }
}
```

## 8ã€ç»“æ„ä½“çš„æ–¹æ³•

ä½ å¯ä»¥ä¸ºè‡ªå®šä¹‰çš„ç»“æ„ä½“å®šä¹‰æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}
```

å£°æ˜æ–¹æ³•è¿‡åï¼Œä½ å¯ä»¥åƒè¿™æ ·ä½¿ç”¨å®ƒä»¬ï¼š
```rust
fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!("positive? {}", minus_two.is_strictly_positive());
// è¾“å‡ºï¼š
// positive? false
}
```

## 9ã€å†è°ˆå˜é‡ç»‘å®š

å˜é‡ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼Œä¹Ÿå°±æ„å‘³ç€æ— æ³•ä¿®æ”¹å…¶å†…éƒ¨å€¼ã€‚
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n.odd = false; // error: cannot assign to `n.odd`,
                   // as `n` is not declared to be mutable
                   // è¯‘ï¼šä¸èƒ½ç»™ n.dd èµ‹å€¼ï¼Œå› ä¸º n æ²¡æœ‰è¢«å£°æ˜ä¸ºå¯å˜ã€‚
}
```

ä¸‹é¢è¿™ç§æƒ…å†µä¹Ÿä¸èƒ½ä¿®æ”¹ï¼š
```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}      // è¯‘ï¼šä¸èƒ½ç»™ä¸å¯å˜å˜é‡ n èµ‹å€¼ä¸¤æ¬¡ã€‚
``` 
å¯ä»¥ `mut` å…³é”®å­—æ¥ä½¿å˜é‡ç»‘å®šå¯å˜ã€‚
```rust
fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // æ­£å¸¸è¿è¡Œ
}
```

## 10ã€Trait

ç‰¹è´¨ï¼ˆTraitï¼‰å¯ä»¥åŒæ—¶è¢«å¤šç§ç±»å‹åŒæ—¶æ‹¥æœ‰ï¼š
```rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
```

å¹¶ä¸æ˜¯ä»»ä½•ç±»å‹éƒ½èƒ½å®ç°ä»»ä½• Traitï¼Œè¿™äº›é™åˆ¶è¢«ç§°ä¸º Trait çš„å­¤å„¿åŸåˆ™ï¼š
- åœ¨ä»»ä½•ç±»å‹ä¸Šéƒ½å¯ä»¥å®ç°ä½ çš„ Traitã€‚
- åœ¨ä½ è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå¯ä»¥å®ç°ä»»æ„ Traitã€‚
- ä½†ä¸èƒ½åœ¨å¤–éƒ¨çš„ç±»å‹ä¸Šå®ç°å¤–éƒ¨çš„ Traitã€‚
> PSï¼šæ— æ³•ä¸ºå¤–éƒ¨ç±»å‹å®ç°å¤–éƒ¨ Traitï¼Œä¾‹å¦‚ä¸º Vec å®ç° Display traitã€‚

ç®€è€Œè¨€ä¹‹ï¼Œåœ¨æŸä¸ªç±»å‹ä¸Šå®ç° Trait çš„å‰ææ¡ä»¶æ˜¯**ç±»å‹æˆ–è€… Trait æ˜¯åœ¨æœ¬åœ° crate ä¸­å®šä¹‰çš„**ã€‚

ä¸‹é¢åœ¨è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå®ç°äº†è‡ªå·±çš„ Traitï¼š
```rust
impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); 
    // è¾“å‡ºï¼š true
}
```

åœ¨è‡ªå®šä¹‰çš„ç±»å‹ä¸Šå®ç°å¤–éƒ¨ Trait 
```rust
// åç§°ä¸º Neg çš„ Trait ç”¨äºé‡è½½è´Ÿå·â€œ-â€ã€‚
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }        
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // ä¸Šé¢å®ç°äº† Neg è¿™ä¸ª Traitï¼Œæ‰€ä»¥å¯ä»¥åœ¨ Number ç±»å‹çš„å˜é‡å‰ä½¿ç”¨è´Ÿå·ã€‚
    println!("{}", m.value); 
    // è¾“å‡ºï¼š-987
}
```

`impl` ä»£ç å—æ€»æ˜¯å’ŒæŸç§ç±»å‹å…³è”ï¼Œå› æ­¤ï¼Œåœ¨ä»£ç å—ä¸­ï¼Œ`Self` æŒ‡å½“å‰ä»£ç å—å…³è”çš„ç±»å‹ã€‚
```rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }        
    }
}
```
ä¸€äº› Trait åªæ˜¯èµ·æ ‡è¯†ä½œç”¨ï¼Œè¿™äº› Trait ä¸éœ€è¦å®ç°ï¼Œå®ƒä»¬åªæ˜¯æ ‡è¯†è¿™ç§ç±»å‹å¯ä»¥åšæŸäº›äº‹ã€‚å¦‚ `Copy` Traitã€‚

`i32` å®ç°äº†åä¸º `Copy` çš„ Traitï¼š
```rust
fn main() {
    let a: i32 = 15;
    let b = a; // å˜é‡ a è¢«å¤åˆ¶
    let c = a; // å˜é‡ a è¢«å†æ¬¡å¤åˆ¶
}
``` 

ä¸‹é¢çš„ä»£ç ä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œ
```rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}
```

ä½†æ˜¯ `Number` ç»“æ„ä½“å´æ²¡æœ‰ä½¿ç”¨ `Copy` è¿›è¡Œæ ‡è¯†ï¼Œæ‰€ä»¥ä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // å˜é‡ n è¢«ç§»åŠ¨åˆ°å˜é‡ mï¼ˆå˜é‡ n ä¼šè¢«é”€æ¯ï¼‰ã€‚ 
    let o = n; // error: use of moved value: `n`
               // è¯‘ï¼šé”™è¯¯ï¼šä½¿ç”¨å·²ç»è¢«ç§»åŠ¨çš„å˜é‡ nã€‚
}
```

ä¸‹é¢çš„ä»£ç ä¹Ÿä¼šæŠ¥é”™ï¼š
```rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // å˜é‡ n è¢«ç§»åŠ¨
    print_number(n); // error: use of moved value: `n`
}
```    

ä½¿ç”¨**ä¸å¯å˜å¼•ç”¨**å°±å¯ä»¥æ­£å¸¸è¿è¡Œäº†ï¼š
```rust
fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // å˜é‡ n è¢«å€Ÿç”¨ã€‚
    print_number(&n); // å˜é‡ n è¢«å†æ¬¡å€Ÿç”¨ã€‚
}
```

å¯ä»¥ä½¿ç”¨å¯å˜å¼•ç”¨æ¥æ”¹å˜åŸå˜é‡çš„å€¼ï¼š
```rust
struct Number {
    odd: bool,
    value: i32,
}

fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // å˜é‡ n æ˜¯å¯å˜
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    // å¯å˜å€Ÿç”¨
    invert(&mut n); 
    // å¯å˜å€Ÿç”¨ç»“æŸ

    // ä¸å¯å˜å€Ÿç”¨
    print_number(&n);
    // ä¸å¯å˜å€Ÿç”¨ç»“æŸ
}
// è¾“å‡ºï¼š
// odd number 51
// odd number -51
```

Trait æ–¹æ³•ä¹Ÿå¯ä»¥ä½¿ç”¨ `self` æ¥å¼•ç”¨å˜é‡è‡ªèº«ï¼š
```rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
```

å½“è°ƒç”¨ Trait æ–¹æ³•æ—¶ï¼Œè°ƒç”¨è€…ä¼šè¢«éšå¼å€Ÿç”¨ã€‚
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone(); // éšå¼å€Ÿç”¨
    m.value += 100;
    
    print_number(&n);
    print_number(&m);
}
``` 

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸‹é¢ä¸¤ç§å†™æ³•æ˜¯ç­‰ä»·çš„ï¼š
```rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
```
åƒ `Copy` è¿™æ ·èµ·æ ‡è¯†ä½œç”¨çš„ Traitï¼Œä¹Ÿå«åš markerï¼Œè¿™ç§ Trait ä¸éœ€è¦å®ç°å…·ä½“çš„æ–¹æ³•ã€‚
```rust
// Noteï¼šClone éœ€è¦å®ç°æ–¹æ³•ã€‚
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
```

ç”±äº `Number` å®ç°äº† Copy Trait å’Œ Clone Traitï¼Œå˜é‡ n çš„æ‰€æœ‰æƒä¸ä¼šè½¬ç§»åˆ° m å’Œ o ä¸Šï¼š
```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // å˜é‡ m æ˜¯å˜é‡ n çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯æŠŠå˜é‡ n ç§»åŠ¨åˆ°å˜é‡ mã€‚
    let o = n; // åŒä¸Šã€‚
}
```

è¿™ä¸¤ç§ Trait éå¸¸å¸¸ç”¨ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨ `derive` å±æ€§æ¥è‡ªåŠ¨å®ç°ï¼š
```rust
#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}

// ä¸Šé¢å®ç°äº† Copy å’Œ Clone ä¸¤ä¸ª Traitï¼Œä¸ä¸Šé¢çš„ `impl Clone for Number`ã€`impl Copy for Number`çš„ä»£ç å—æ•ˆæœä¸€æ ·ã€‚
```

## 11ã€æ³›å‹

åœ¨ Rust ä¸­å¯ä»¥ä½¿ç”¨æ³›å‹æ¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ã€‚å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
// T å«åšæ³›å‹å‚æ•°åç§°
fn foobar<T>(arg: T) {
}
```

å‡½æ•°å¯ä»¥æœ‰å¤šä¸ªæ³›å‹å‚æ•°åç§°ï¼š
```rust
fn foobar<L, R>(left: L, right: R) {
    // ä½¿ç”¨ left å’Œ right å‚æ•°
}
```

æ³›å‹å‚æ•°å¯ä»¥è®¾ç½®çº¦æŸæ¡ä»¶ï¼Œæœ€ç®€å•çš„çº¦æŸæ¡ä»¶å°±æ˜¯ Trait åç§°ï¼š
```rust
// å‚æ•°ç±»å‹ T å¿…é¡»å®ç° Display Trait
fn print<T: Display>(value: T) {
    println!("value = {}", value);
}

// å‚æ•°ç±»å‹ T å¿…é¡»å®ç° Debug Trait
fn print<T: Debug>(value: T) {
    println!("value = {:?}", value);
}
```

ä¹Ÿå¯ä»¥å†™æˆä¸‹é¢è¿™æ ·
```rust
fn print<T>(value: T)
where
    T: Display,
{
    println!("value = {}", value);
}
```

çº¦æŸæ¡ä»¶å¯ä»¥è¦æ±‚å‚æ•°ç±»å‹åŒæ—¶å®ç°å¤šç§ Traitï¼š
```rust
use std::fmt::Debug;

// å‚æ•°ç±»å‹ T å¿…é¡»åŒæ—¶å®ç° Debug å’Œ PartialEq ä¸¤ç§ Trait
fn compare<T>(left: T, right: T)
where
    T: Debug + PartialEq,
{
    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);
}

fn main() {
    compare("tea", "coffee");
    // è¾“å‡ºï¼š
    // "tea" != "coffee"
}
```

æ³›å‹å‡½æ•°å¯ä»¥è¢«è®¤ä¸ºæ˜¯å‘½åç©ºé—´ï¼Œå®ƒåŒ…å«æ— æ•°å…·ä½“ç±»å‹çš„å‡½æ•°ã€‚

ç±»ä¼¼åŒ…ï¼ˆcrateï¼‰ã€æ¨¡å—ï¼ˆmoduleï¼‰å’Œæ•°æ®ç±»å‹ï¼ˆTypeï¼‰ï¼Œæ³›å‹å‡½æ•°å¯ä»¥ä½¿ç”¨ `::` æ¥è®¿é—®æŸç§å…·ä½“ç±»å‹çš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼š
```rust
fn main() {
    use std::any::type_name;
    println!("{}", type_name::<i32>()); // è¾“å‡ºï¼ši32
    println!("{}", type_name::<(f64, char)>()); // è¾“å‡ºï¼š(f64, char)
}
```
è¿™ç§è¯­æ³•è¢«äº²åˆ‡çš„ç§°ä¸º Turbofish è¯­æ³•ï¼ˆæ¶¡è½®é±¼è¯­æ³•ï¼‰ï¼Œå› ä¸º `::<>` çœ‹èµ·æ¥åƒæ˜¯ä¸€æ¡é±¼ã€‚

åœ¨ç»“æ„ä½“ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨æ³›å‹ï¼š
```rust
struct Pair<T> {
    a: T,
    b: T,
}

fn print_type_name<T>(_val: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&p1); // è¾“å‡ºï¼šPair<i32>
    print_type_name(&p2); // è¾“å‡ºï¼šPair<bool>
}
```

æ ‡å‡†åº“ä¸­çš„ `Vec` å°±æ˜¯ä¸€ç§æ³›å‹çš„ç»“æ„ä½“ï¼š
```rust
fn main() {
    let mut v1 = Vec::new();
    v1.push(1);
    let mut v2 = Vec::new();
    v2.push(false);
    print_type_name(&v1); // è¾“å‡ºï¼šVec<i32>
    print_type_name(&v2); // è¾“å‡ºï¼šVec<bool>
}
```

## 12ã€å®


`Vec` é…å¤‡äº†ä¸€ä¸ªå®ï¼Œä½¿ç”¨ `vec!` å¯ä»¥ä¾¿æ·çš„åˆå§‹åŒ–ä¸€ä¸ªåŠ¨æ€æ•°ç»„ã€‚
```rust
fn main() {
    let v1 = vec![1, 2, 3];
    // vec!()ã€vec![]ã€vec!{} éƒ½å¯ä»¥è°ƒç”¨å®ã€‚
    let v2 = vec![true, false, true];
    print_type_name(&v1); // è¾“å‡ºï¼š "Vec<i32>"
    print_type_name(&v2); // è¾“å‡ºï¼š "Vec<bool>"
}
```

`println` ä¹Ÿæ˜¯ä¸€ä¸ªå®ï¼š
```rust
fn main() {
    println!("{}", "Hello there!");
}
```

å®è¢«è°ƒç”¨åä¼šè¢«å±•å¼€æˆå…¶å®ƒä»£ç ï¼Œ`println!` å±•å¼€åçš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
fn main() {
    use std::io::{self, Write};
    io::stdout().lock().write_all(b"Hello there!\n").unwrap();
}
```

`panic!` ä¹Ÿæ˜¯ä¸€ä¸ªå®ï¼Œå®ƒä¼šç«‹å³åœæ­¢ç¨‹åºå¹¶è¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼š
```rust
fn main() {
    panic!("This panics");
}
// è¾“å‡ºï¼šthread 'main' panicked at 'This panics', src/main.rs:3:5
// è¯‘ï¼šçº¿ç¨‹ main çš„å¼‚å¸¸ä½äº â€œThis panicsâ€ï¼Œsrc/main. rs:3:5
```

ä¸€äº›å‡½æ•°ä¹Ÿä½¿ç”¨åˆ°äº† `panic!`ã€‚æ¯”å¦‚ `Option` ç±»å‹ä¸­çš„ `unwrap` å‡½æ•°ã€‚

## 13ã€æšä¸¾ç±»å‹

`Option` æ˜¯ä¸€ç§æšä¸¾ç±»å‹ï¼Œå¯ä»¥åŒ…å«å€¼ï¼Œä¹Ÿå¯ä»¥ä¸ºç©ºã€‚å½“ `Option` ä¸ºç©ºæ—¶è°ƒç”¨ `unwrap()` å‡½æ•°ä¼šé€ æˆ `panic`ï¼Œå³ç¨‹åºä¸­æ–­ã€‚
```rust
fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // æ­£å¸¸æ‰§è¡Œ

    let o2: Option<i32> = None;
    o2.unwrap(); // panic å¼‚å¸¸
}
// è¾“å‡ºï¼šthread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
```

`Option` ç±»å‹åªæœ‰ä¸¤ç§å€¼ï¼Œè¦ä¹ˆæ˜¯ `Some(T)`, è¦ä¹ˆä¸º `None`ã€‚`Option` çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š
```rust
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        // æšä¸¾å˜é‡å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ã€‚
        match self {
            Self::Some(t) => t,
            Self::None => panic!(".unwrap() called on a None option"),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // æ­£å¸¸è¿è¡Œ

    let o2: Option<i32> = None;
    o2.unwrap(); // panic å¼‚å¸¸
}

// è¾“å‡ºï¼šthread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27
```

`Result` ä¹Ÿæ˜¯ä¸€ç§æšä¸¾ç±»å‹ï¼Œç±»ä¼¼ `Option`ï¼Œå®ƒä¹Ÿåªæœ‰ä¸¤ç§å€¼ï¼Œè¦ä¹ˆæ˜¯ `Ok(T)`ï¼Œè¦ä¹ˆæ˜¯ `Err(E)`ã€‚
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

å½“ `Result` çš„å€¼ä¸º `Err(E)` æ—¶ï¼Œè°ƒç”¨ `unwrap()` å‡½æ•°ä¹Ÿä¼šé€ æˆ `panic`ã€‚

## 14ã€ç”Ÿå‘½å‘¨æœŸä¸å€Ÿç”¨

æ‰€æœ‰çš„å˜é‡ç»‘å®šéƒ½æœ‰ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn main() {
    // å˜é‡ x ä¸å­˜åœ¨
    {
        let x = 42; // å˜é‡ x å­˜åœ¨
        println!("x = {}", x);
        // å˜é‡ X è¢«é”€æ¯
    }
    // å˜é‡ x ä¸å­˜åœ¨
}
```

æ‰€æœ‰çš„å¼•ç”¨ä¹Ÿéƒ½æœ‰ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn main() {
    // å˜é‡ x ä¸å­˜åœ¨
    {
        let x = 42; // å˜é‡ x å­˜åœ¨
        let x_ref = &x; // å˜é‡ x_ref å­˜åœ¨ï¼Œå¹¶ä¸”å€Ÿç”¨äº†å˜é‡ xã€‚
        println!("x_ref = {}", x_ref);
        // å˜é‡ x_ref è¢«é”€æ¯
        // å˜é‡ x è¢«é”€æ¯
    }
    // å˜é‡ x ä¸å­˜åœ¨
}
```

å‡½æ•°å‚æ•°ä¸­çš„å¼•ç”¨ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸã€‚
```rust
fn print(x: &i32) {
    // å˜é‡ x æ˜¯å¤–éƒ¨å˜é‡çš„å€Ÿç”¨ã€‚å½“å‡½æ•°è¢«é”€æ¯æ—¶ï¼Œå˜é‡ x ä¹Ÿä¼šè¢«é”€æ¯ã€‚
}
```

**è¢«å€Ÿç”¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ**å¿…é¡»å¤§äºæˆ–ç­‰äºï¼ˆ<=ï¼‰**å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ**ã€‚
> è·å–å˜é‡çš„å¼•ç”¨çš„è¡Œä¸ºç§°ä¹‹ä¸ºå€Ÿç”¨ã€‚
```rust
fn main() {
    let x_ref = {
        // è¢«å€Ÿç”¨å˜é‡
        let x = 42;
        // å¼•ç”¨
        &x
    };
    println!("x_ref = {}", x_ref);
    // error: `x` does not live long enough
}
```

ä¸€ä¸ªå˜é‡è¢«å¯ä»¥å¤šæ¬¡ä¸å¯å˜å€Ÿç”¨
```rust
fn main() {
    let x = 42;
    let x_ref1 = &x;
    let x_ref2 = &x;
    let x_ref3 = &x;
    println!("{} {} {}", x_ref1, x_ref2, x_ref3);
}
```

å˜é‡è¢«å€Ÿç”¨çš„æ—¶å€™ï¼ˆæ— è®ºæ˜¯å¯å˜å€Ÿç”¨ï¼Œè¿˜æ˜¯ä¸å¯å˜å€Ÿç”¨ï¼‰ï¼Œä¸èƒ½è¢«ä¿®æ”¹ã€‚
```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;

    // s.push('a');
    r1.push('b');
    
    println!("{}", r1);
}

```

å˜é‡ç»‘å®šè¢«ä¸å¯å˜å€Ÿç”¨çš„æ—¶å€™ï¼Œä¸èƒ½å†è¢«å¯å˜å€Ÿç”¨ã€‚
```rust
fn main() {
    let mut x = 42;
    let x_ref1 = &x;
    let x_ref2 = &mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    // è¯‘ï¼šé”™è¯¯ï¼šä¸èƒ½å°†å˜é‡ x ä½œä¸ºå¯å˜å€Ÿç”¨ï¼Œå› ä¸ºå˜é‡ x å·²ç»è¢«ä¸å¯å˜å€Ÿç”¨ã€‚
    println!("x_ref1 = {}", x_ref1);
}
```

## 15ã€ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨

é¦–å…ˆäº†è§£ä¸€ä¸‹æ³›å‹ç”Ÿå‘½å‘¨æœŸï¼Œ`fn foo<'a>(x: &'a i32)` æ˜¯ä¸€ä¸ªå¸¸è§çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„æ¡ˆä¾‹ï¼Œå…¶ä¸­ `'a` æ˜¯æ³›å‹çš„ã€‚è¿™é‡Œçš„æ³›å‹æ˜¯æŒ‡**å®å‚çš„ç”Ÿå‘½å‘¨æœŸå¯ä»¥ä¸åŒ**ã€‚

ä¸€ä¸ªå‡½æ•°å¯ä»¥æ‹¥æœ‰ä¸åŒçš„å¼•ç”¨å‚æ•°ï¼Œå¹¶ä¸”æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰å¯¹åº”çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸï¼š
```rust
// ä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°å°±æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn foo<'a>(x: &'a i32)

// ä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°å¯ä»¥æœ‰ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
```

ç”Ÿå‘½å‘¨æœŸæœ‰ä¸¤ç§æ ‡æ³¨æ–¹å¼ï¼š
- **è‡ªåŠ¨æ ‡æ³¨**ï¼šå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯å¯ä»¥è¢«æ¨å¯¼å‡ºæ¥çš„ï¼Œå°±å¦‚åŒå¤§éƒ¨åˆ†æ—¶å€™ç±»å‹ä¹Ÿæ˜¯å¯ä»¥è¢«æ¨å¯¼çš„ä¸€æ ·ã€‚è¿™ç§ç”Ÿå‘½å‘¨æœŸè¢«ç§°ä¸º**çœç•¥ç”Ÿå‘½å‘¨æœŸ**ã€‚
- **æ‰‹åŠ¨æ ‡æ³¨**ï¼šå½“å‡ºç°å¤šä¸ªå¯èƒ½çš„ç±»å‹æ—¶ï¼Œç¼–è¯‘å™¨æ— æ³•æ¨å¯¼å‡ºç”Ÿå‘½å‘¨æœŸï¼Œè¿™æ—¶æˆ‘ä»¬å°±éœ€è¦æ‰‹åŠ¨**æ ‡æ³¨**ç”Ÿå‘½å‘¨æœŸã€‚è¿™ç§ç”Ÿå‘½å‘¨æœŸç§°ä¸º**å‘½åç”Ÿå‘½å‘¨æœŸ**ã€‚

è¿™é‡Œæˆ‘ä»¬ä¸»è¦ä»‹ç»æ‰‹åŠ¨æ ‡æ³¨ï¼Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä»¥å•å¼•å· `'` å¼€å¤´
```rust
// çœç•¥ç”Ÿå‘½å‘¨æœŸï¼ˆæ²¡æœ‰åå­—çš„ç”Ÿå‘½å‘¨æœŸï¼‰ï¼š
fn print(x: &i32) {}

// å‘½åç”Ÿå‘½å‘¨æœŸï¼š
fn print<'a>(x: &'a i32) {}
```

å‡½æ•°å¯ä»¥è¿”å›å€¼çš„å¼•ç”¨ï¼Œè¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¾èµ–äºå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸï¼š
```rust
struct Number {
    value: i32,
}

fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&n);
    // å˜é‡ v ä¸å¯å˜çš„å€Ÿç”¨å˜é‡ nï¼Œå› æ­¤å˜é‡ v çš„ç”Ÿå‘½å‘¨æœŸä¸è¶…è¿‡å˜é‡ n çš„ç”Ÿå‘½å‘¨æœŸã€‚
    // å½“å˜é‡ v å­˜åœ¨æ—¶ï¼Œå˜é‡ n ä¸èƒ½è¢«å¯å˜çš„å€Ÿç”¨ã€ä¸èƒ½ä¿®æ”¹ï¼Œä¹Ÿä¸èƒ½è¢«ç§»åŠ¨ã€‚
}
```
å½“åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œå¯ä»¥ä¸å‘½åï¼ˆç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ ‡æ³¨ï¼‰ã€‚æ‰€æœ‰çš„å˜é‡éƒ½æ‹¥æœ‰åŒä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤ï¼Œä¸‹é¢ä¸¤ä¸ªå‡½æ•°æ˜¯ç­‰ä»·çš„ï¼š
```rust
fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn number_value(num: &Number) -> &i32 {
    &num.value
}
```
åœ¨ç»“æ„ä½“ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¼•ç”¨ï¼Œæ¯ä¸ªå¼•ç”¨éƒ½éœ€è¦æ ‡æ³¨ä¸Šç”Ÿå‘½å‘¨æœŸã€‚
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &x };
    // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡ï¼ˆ<=ï¼‰å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```

ä»£ç åŒä¸Šï¼Œä½¿ç”¨å‡½æ•°æ¥åˆ›å»º NumRefï¼š
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```

ä»£ç åŒä¸Šï¼Œè¿ç”¨äº†**ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™**ï¼š
> ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™å¯ä»¥è®©å¼€å‘è€…æ— éœ€æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œå…·ä½“è§„åˆ™è¯·çœ‹ã€ŠRust åœ£ç»ã€‹ã€‚
```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref(x: &i32) -> NumRef<'_> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
   // å˜é‡ x_ref ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```

NumRef ç±»å‹çš„ `impl` å—ä¹Ÿéœ€è¦æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼š
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&'a self) -> &'a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // å˜é‡ x_num_ref å’Œå˜é‡ x_i32_ref çš„ç”Ÿå‘½å‘¨æœŸéƒ½æ¯”å˜é‡ x çš„ç”Ÿå‘½å‘¨æœŸçŸ­ã€‚
}
```

å†æ¬¡è¿ç”¨**ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™**ï¼š
```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```

è¿˜å¯ä»¥æ¶ˆé™¤æ›´å¤šï¼š
```rust
impl NumRef<'_> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```

æœ‰ä¸€ç§ç‰¹æ®Šçš„ç”Ÿå‘½å‘¨æœŸï¼Œå«åš`'static`ï¼Œæ‹¥æœ‰è¯¥ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨å¯ä»¥å’Œæ•´ä¸ªç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ã€‚
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let p = Person {
        name: "fasterthanlime",
    };
}
```

æ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²ï¼ˆStringï¼‰ä¸æ˜¯é™æ€çš„ï¼š
```rust
struct Person {
    name: &'static str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // error: `name` does not live long enough
    // è¯‘ï¼šé”™è¯¯ï¼šå˜é‡ name æ´»å¾—ä¸å¤Ÿé•¿ã€‚
}
```

å¯ä»¥é€šè¿‡ä¸‹é¢çš„æ–¹æ³•æ¥æ‰“å°å­—ç¬¦ä¸²çš„ç±»å‹ï¼š
```rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    print_type_of(&name);
}
// è¾“å‡ºï¼šalloc::string::String
```

å˜é‡ name ä¸èƒ½ä½œä¸ºé™æ€å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼ˆå³ `&'static str`ï¼‰ã€‚å˜é‡ name æ˜¯è¢«åŠ¨æ€åˆ†é…çš„ï¼Œä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯çŸ­äºæ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚

å¦‚éœ€å­˜å‚¨ä¸€ä¸ªéé™æ€çš„å­—ç¬¦ä¸²åˆ° `Person` ä¸­ï¼Œå¯ä»¥è€ƒè™‘ï¼š
1. ä½¿ç”¨æ™®é€šçš„ç”Ÿå‘½å‘¨æœŸ
```rust
struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // å˜é‡ p çš„ç”Ÿå‘½å‘¨æœŸçŸ­äºå˜é‡ name çš„ç”Ÿå‘½å‘¨æœŸã€‚
}
```

2. è·å–å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒã€‚
```rust
struct Person {
    name: String,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: name };
    // `name` was moved into `p`, their lifetimes are no longer tied.
}
```

## 16ã€åˆ‡ç‰‡

Rust ä¸­åˆ‡ç‰‡æ˜¯æŒ‡**ä¸æŒæœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹**ï¼ˆç±»ä¼¼è§†å›¾ï¼‰ï¼Œå­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ `&str`ï¼Œå°±æ˜¯åˆ‡ç‰‡çš„ä¸€ç§ã€‚
```rust
fn main() {
    let s: &str = "Hello, world!";
    let s1 = &s[0..5];  // [å¼€å§‹ç´¢å¼•..ç»ˆæ­¢ç´¢å¼•]
    // s1 æŒ‡å‘å˜é‡ s çš„ start_index åˆ° end_index åŒºé—´çš„å­—ç¬¦ä¸² 

    println!("{}", s1);
    // è¾“å‡ºï¼š
    // Hello
}
```

å­—ç¬¦ä¸²è°ƒç”¨ `split` å‡½æ•°åï¼Œä¸åˆ›å»ºæ–°çš„å­—ç¬¦ä¸²ï¼Œåªæ˜¯å°†å­—ç¬¦ä¸²çš„å¼•ç”¨ä¼ å‡ºï¼š
```rust
fn file_ext(name: &str) -> Option<&str> {
    // ä¸åˆ›å»ºæ–°çš„å­—ç¬¦ä¸²
    name.split(".").last()
}

fn main() {
    let name = "Read me. Or don't.txt";
    if let Some(ext) = file_ext(name) {
        println!("file extension: {}", ext);
    } else {
        println!("no file extension");
    }
}
```

`..` è¯­æ³•æ˜¯ Range çš„å­—é¢é‡ï¼Œåªæœ‰å°‘æ•°çš„ç»“æ„å¯ä»¥ç›´æ¥ä½¿ç”¨ `..` è¯­æ³•ã€‚`[0..5]` æ˜¯**åŠé—­åŠå¼€**çš„ï¼Œå¼€å§‹ç´¢å¼•æ˜¯åˆ‡ç‰‡ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ä½ç½®ï¼Œç»ˆæ­¢ç´¢å¼•æ˜¯æœ€åä¸€ä¸ªå…ƒç´ åé¢çš„ç´¢å¼•ä½ç½®ã€‚

å¯ä»¥ä½¿ç”¨ `=` ç¬¦å·æ¥è®©å³ä¾§é—­åˆã€‚
```rust
fn main() {
    // å¤§äº 0 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (0..).contains(&100)); // true
    // å°äº 20 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (..20).contains(&20)); // false
    // å°äºç­‰äº 20 çš„æ‰€æœ‰æ•°å­—
    println!("{:?}", (..=20).contains(&20)); // true
    // 3ã€4ã€5
    println!("{:?}", (3..6).contains(&4)); // true
}
```

æ•°ç»„ä¹Ÿæœ‰åˆ‡ç‰‡ï¼š
```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let v2 = &v[2..4];
    println!("v2 = {:?}", v2);
}

// è¾“å‡ºï¼š
// v2 = [3, 4]
```

åœ¨ä½¿ç”¨åˆ‡ç‰‡çš„æ—¶å€™è¦éµå¾ªå€Ÿç”¨è§„åˆ™ï¼š
```rust
fn tail<'a>(s: &'a [u8]) -> &'a [u8] {
  &s[1..] 
}

fn main() {
    let y = {
        let x = &[1, 2, 3, 4, 5];
        // [1, 2, 3, 4, 5] ç±»ä¼¼ strï¼Œç¡¬ç¼–ç åˆ°ç¨‹åºä¸­ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯ 'staticã€‚
        tail(x)
    };
    println!("y = {:?}", y);
}
// è¾“å‡ºï¼š
// y = [2, 3, 4, 5]
```

`vec!` å®åœ¨å †ä¸Šåˆ†é…å†…å­˜ï¼Œå½“ç¦»å¼€ä½œç”¨åŸŸåä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ï¼Œå› æ­¤ç›¸å…³çš„å¼•ç”¨ä¹Ÿä¼šæ¶ˆå¤±ï¼š
```rust
fn tail(s: &[u8]) -> &[u8] {
    &s[1..]
}

fn main() {
    let y = {
        let v = vec![1, 2, 3, 4, 5];
        tail(&v)
        // error: `v` does not live long enough
    };  // v ç¦»å¼€ä½œç”¨åŸŸï¼Œè‡ªåŠ¨é‡Šæ”¾ã€‚
    println!("y = {:?}", y);
}
```



## 17ã€å¼‚å¸¸å¤„ç†

å‡½æ•°å‘ç”Ÿé”™è¯¯åï¼Œé€šå¸¸ä¼šè¿”å› `Result` ç±»å‹çš„æ•°æ®ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]);
    println!("{:?}", s);
    // è¾“å‡ºï¼šOk("ğŸ‰")

    let s = std::str::from_utf8(&[195, 40]);
    println!("{:?}", s);
    // è¾“å‡ºï¼šErr(Utf8Error { valid_up_to: 0, error_len: Some(1) })
}
```

å¦‚æœä½ å¸Œæœ›åœ¨ç¨‹åºé”™è¯¯å panicï¼Œä½ å¯ä»¥ä½¿ç”¨ `.unwrap()`ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();
    println!("{:?}", s);
    // è¾“å‡ºï¼š"ğŸ‰"

    let s = std::str::from_utf8(&[195, 40]).unwrap();
    // è¾“å‡ºï¼šthread 'main' panicked at 'called `Result::unwrap()`
    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',
    // src/libcore/result.rs:1165:5
}
```

ä½¿ç”¨ `.expect()` å¯ä»¥è‡ªå®šä¹‰æ¶ˆæ¯ï¼š
```rust
fn main() {
    let s = std::str::from_utf8(&[195, 40]).expect("valid utf-8");
    // è¾“å‡ºï¼šthread 'main' panicked at 'valid utf-8: Utf8Error
    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
    // è¯‘ï¼šçº¿ç¨‹ main å‘ç”Ÿå¼‚å¸¸ï¼ŒåŸå› ä¸º valid utf-8ï¼šUtf8Error { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
}
```

æ›´ä¼˜é›…çš„æ–¹å¼æ˜¯ä½¿ç”¨ `match` æ¥å¤„ç†å¼‚å¸¸ï¼š
```rust
fn main() {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => panic!(e),
    }
    // è¾“å‡ºï¼š ğŸ‰
}
```

å½“ç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ `if let` æ¥åŒ¹é…ï¼š
```rust
fn main() {
    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {
        println!("{}", s);
    }
    // è¾“å‡ºï¼šğŸ‰
}
```

ä½¿ç”¨ `return` å°†å¼‚å¸¸ä¼ é€’å‡ºå»ï¼š
```rust
fn main() -> Result<(), std::str::Utf8Error> {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => return Err(e),
    }
    Ok(())
    // è¾“å‡ºï¼šğŸ‰
}
```

ç”±äºä¼ é€’é”™è¯¯çš„æ¨¡å¼åœ¨ Rust ä¸­éå¸¸å¸¸è§ï¼Œæ‰€ä»¥ Rust ä¸“é—¨æä¾›äº†ä¸€ä¸ªé—®å·è¿ç®—ç¬¦ `?` æ¥ç®€å†™ï¼š
```rust
fn main() -> Result<(), std::str::Utf8Error> {
    let s = std::str::from_utf8(&[240, 159, 141, 137])?;
    println!("{}", s);
    Ok(())
    // è¾“å‡ºï¼šğŸ‰
}
// ä½œç”¨å’Œä¸Šä¸€ä¸ªä»£ç ç‰‡æ®µç›¸åŒ
```

## 18ã€è§£å¼•ç”¨

æ˜Ÿå· `*` æ“ä½œç¬¦å¯ä»¥ç”¨äºè§£æ„å¼•ç”¨ï¼Œä½†å½“ä½ **è®¿é—®å­—æ®µ**æˆ–è€…**è°ƒç”¨æ–¹æ³•**æ—¶ä¸éœ€è¦æ‰‹åŠ¨è§£å¼•ç”¨ï¼Œå› ä¸º Rust ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼š
```rust
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;                             // p_ref->p->(x, y)
    println!("({}, {})", p_ref.x, p_ref.y);     // è‡ªåŠ¨è§£å¼•ç”¨
}

// è¾“å‡ºï¼š (1, 3)
```

**èµ‹å€¼æ“ä½œ**éœ€è¦æ‰‹åŠ¨è§£å¼•ç”¨ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ**å°†å€¼ä¼ é€’ç»™å‡½æ•°**å’Œ**å°†å€¼èµ‹ç»™å˜é‡**æ˜¯ç±»ä¼¼çš„è¡Œä¸ºï¼š
```rust
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -> Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;

    // negate(p_ref); 
    // error: expected struct `Point`, found `&Point`

    negate(*p_ref); 
    // å°†å€¼ä¼ é€’ç»™å‡½æ•°
}
```

## 19ã€é—­åŒ…

é—­åŒ…æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ•°æ®ç»“æ„ï¼Œå› æ­¤é—­åŒ…ä¹Ÿæœ‰ä¸€äº›ç‰¹æ®Šçš„ Traitã€‚é—­åŒ… Trait é€šå¸¸ç”¨æ¥çº¦æŸé—­åŒ…çš„**å‚æ•°ç±»å‹**å’Œ**è¿”å›å€¼ç±»å‹**ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯ï¼š
- **FnOnce**ï¼šå–å¾—ç¯å¢ƒä¸­å˜é‡çš„æ‰€æœ‰æƒã€‚
- **FnMut**ï¼šä»ç¯å¢ƒä¸­å¯å˜çš„å€Ÿç”¨å€¼ã€‚
- **Fn**ï¼šä»ç¯å¢ƒä¸­ä¸å¯å˜çš„å€Ÿç”¨å€¼ã€‚

é—­åŒ…å‡½æ•°çš„å‚æ•°å†™åœ¨ä¸€å¯¹ç®¡é“ç¬¦ `|` ä¹‹é—´ï¼Œå¹¶ä½¿ç”¨é€—å·åˆ†å¼€ã€‚å¦‚æœé—­åŒ…åªæœ‰ä¸€æ¡è¯­å¥ï¼Œå¯ä»¥ä¸ç”¨å†™å¤§æ‹¬å·ã€‚
```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}
 
fn main() {
    for_each_planet(|planet| println!("Hello, {}", planet));
}

// è¾“å‡ºï¼š
// Hello, Earth
// Hello, Mars
// Hello, Jupiter
```
`Fn` ç±»å‹çš„é—­åŒ…ä»ç¯å¢ƒä¸­ä¸å¯å˜çš„å€Ÿç”¨**å€¼**ï¼š
```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}
 
fn main() {
    let greeting = String::from("Good to see you");

    for_each_planet(| planet | println!("{}, {}", greeting, planet));
    // ä¸å¯å˜çš„å€Ÿç”¨å˜é‡ greeting ä¸­çš„å€¼ï¼Œ
}
// è¾“å‡ºï¼š
// Good to see you, Earth
// Good to see you, Mars
// Good to see you, Jupiter
```
ä¸‹é¢çš„ä»£ç ä¼šæŠ¥é”™ï¼š
```rust
fn for_each_planet<F>(f: F)
where
    F: Fn(&'static str) + 'static, // é—­åŒ… F æ˜¯é™æ€ç”Ÿå‘½å‘¨æœŸã€é—­åŒ… F çš„å‚æ•°ä¹Ÿæ˜¯é™æ€ç”Ÿå‘½å‘¨æœŸ
{
    f("Earth"); // "Earth" æ˜¯é—­åŒ… F çš„å‚æ•°ï¼Œç±»å‹æ˜¯ &'static strã€‚
    f("Mars");
    f("Jupiter");
}

fn main() {
    let greeting = String::from("Good to see you");
    for_each_planet(|planet| println!("{}, {}", greeting, planet));
    // error: closure may outlive the current function, but it borrows
    // `greeting`, which is owned by the current function
    
    // æŠ¥é”™åŸå› ï¼šé—­åŒ…æ˜¯é™æ€ç”Ÿå‘½å‘¨æœŸï¼Œä½†æ˜¯é—­åŒ…å¼•ç”¨äº†éé™æ€ç”Ÿå‘½å‘¨æœŸçš„å˜é‡â€”â€”planetï¼Œä¸æ»¡è¶³ for_each_planet å‡½æ•°çš„è¦æ±‚ã€‚
}
```

ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å°±èƒ½æ­£å¸¸è¿è¡Œäº†ï¼š
```rust
fn main() {
    let greeting = String::from("You're doing great");
    for_each_planet(move |planet| println!("{}, {}", greeting, planet));
}
```

æŸäº›é—­åŒ…éœ€è¦å¯å˜çš„å€Ÿç”¨æœ¬åœ°å˜é‡ï¼Œè¿™å°±éœ€è¦ç”¨åˆ° `FnMut` ç±»å‹ã€‚
```rust
fn foobar<F>(mut func: F)
where
    F: FnMut(i32) -> i32,
{
    let tmp = func(2);          // è°ƒç”¨ func é—­åŒ…ï¼Œacc = 3ï¼Œè¿”å›å€¼ä¸º 2*3=6
    println!("{}", func(tmp));  // è°ƒç”¨ func é—­åŒ…ï¼Œacc = 4ï¼Œè¿”å›å€¼ä¸º 6*4=24
}

fn main() {
    let mut acc = 2;

    // å¯å˜çš„å€Ÿç”¨ acc
    let func = |x| {
        acc += 1;
        x * acc
    };
    // println!("acc value: {}", acc);  // å·²ç»å­˜åœ¨å¯å˜å€Ÿç”¨ï¼Œä¸èƒ½ä¸å¯å˜çš„å€Ÿç”¨ acc
    foobar(func);
    // å¯å˜å€Ÿç”¨ç»“æŸ
    println!("acc value: {}", acc);
}
// è¾“å‡ºï¼š
// 24
// acc value: 4
```

ä¸èƒ½å°†è¿™ç§é—­åŒ…ä½œä¸º `Fn` ç±»å‹çš„å‚æ•°ï¼š
```rust
fn foobar<F>(f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2))); 
}
 
fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        // error: cannot assign to `acc`, as it is a captured variable in a `Fn` closure. the compiler suggests "changing foobar to accept closures that implement `FnMut`"
        // æŠ¥é”™åŸå› ï¼šåœ¨ Fn ç±»å‹çš„é—­åŒ…ä¸­ï¼Œä¸èƒ½ç»™å˜é‡ acc èµ‹å€¼ã€‚ç¼–è¯‘å™¨å»ºè®®è®© foobar å‡½æ•°å…è®¸æ¥å— FnMut ç±»å‹çš„é—­åŒ…ã€‚
        x * acc
    });
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸‹é¢çš„å†™æ³•ä¼šå¯¼è‡´ç¼–è¯‘å™¨å‡ºé”™ï¼š
```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    println!("{}", f(f(2))); 
    // error: second mutable borrow occurs here
    // è§£é‡Šï¼šä¸èƒ½åŒæ—¶å­˜åœ¨ä¸¤æ¬¡å¯å˜å€Ÿç”¨
}
 
fn main() {
    foobar(|x| x * 2);
}
```

å°†ä¸Šé¢çš„ä»£ç ç¨å¾®ä¿®æ”¹ä¸€ä¸‹å°±å¥½äº†ï¼š
```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    // å¯å˜å€Ÿç”¨ 2
    let tmp = f(2);
    // å¯å˜å€Ÿç”¨ç»“æŸ

    // å¯å˜å€Ÿç”¨ tmp
    println!("{}", f(tmp)); 
    // å¯å˜å€Ÿç”¨ç»“æŸ
}
 
fn main() {
    foobar(|x| x * 2);
}

// è¾“å‡ºï¼š8
```

æˆ–è€…å°† `FnMut` æ”¹æˆ `Fn`ï¼š
```rust
fn foobar<F>(mut f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2))); 
}
 
fn main() {
    foobar(|x| x * 2);
}
```

`FnOnce` ç±»å‹çš„é—­åŒ…ä¼šå°†æœ¬åœ°å˜é‡ç§»åŠ¨åˆ°é—­åŒ…ä¸­ï¼š
```rust
fn foobar<F>(func: F)
    where F: FnOnce() -> String
{ 
    let x = func();
    // String æ²¡æœ‰å®ç° Copy Traitï¼Œfunc é—­åŒ…ä¼šå°†å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒè½¬ç§»ç»™ x å˜é‡ã€‚

    println!("{}", x); 
    // println!("{}", func());  // func é—­åŒ…å·²ç»æ²¡æœ‰å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒäº†ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™ã€‚
}
 
fn main() {
    let s = String::from("alright");
    
    let func = move || s;
    // å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒè½¬ç§»ç»™é—­åŒ…
    // println!("{}", s);   // Rust ä¸­æ‰€æœ‰æƒè½¬ç§»ä¼šå°†åŸå˜é‡è®¾ç½®ä¸ºæ— æ•ˆï¼Œæ­¤å¤„ s å˜é‡æ— æ•ˆï¼Œæ‰€ä»¥ä¼šæŠ¥é”™ã€‚

    foobar(func);  
}
```

ä½ å¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥ç¡®å®š `FnOnce` é—­åŒ…æ˜¯å¦å·²ç»ç§»åŠ¨äº†å˜é‡ sï¼š
```rust
fn main() {
    let s = String::from("alright");
    foobar(move || s);
    foobar(move || s);
    // é”™è¯¯ï¼šä½¿ç”¨å·²ç»ç§»åŠ¨çš„å€¼ï¼šs
}
```

å¯ä»¥ä½¿ç”¨ `clone` æ¥è§£å†³ä¸Šé¢çš„é—®é¢˜ï¼š
```rust
fn main() {
    let s = String::from("alright");
    foobar(|| s.clone());
    foobar(|| s.clone());
}
```

é—­åŒ…ä¹Ÿå¯ä»¥è®¾ç½®å¤šä¸ªå‚æ•°ï¼Œå‚æ•°ä¹‹é—´ä½¿ç”¨é€—å· `,` éš”å¼€ï¼š
```rust
fn foobar<F>(x: i32, y: i32, is_greater: F)
    where F: Fn(i32, i32) -> bool
{
    let (greater, smaller) = if is_greater(x, y) {
        (x, y)
    } else {
        (y, x)
    };
    println!("{} is greater than {}", greater, smaller);
}
 
fn main() {
    foobar(32, 64, |x, y| x > y);
}
```

é—­åŒ…å¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ `_` æ¥å¿½ç•¥å‚æ•°ï¼š
```rust
fn main() {
    foobar(32, 64, |_, _| panic!("Comparing is futile!"));
}
```

å‰é¢å·²ç»è®²è¿‡äº† `Range` çš„éå†ã€‚äº‹å®ä¸Šï¼Œä»»ä½•å¯è¿­ä»£çš„å˜é‡éƒ½å¯ä»¥ä½¿ç”¨ `for in` æ¥éå†ï¼Œ`Vec` ç±»å‹å¯ä»¥ä½¿ç”¨ `for in` éå†ï¼š
```rust
fn main() {
    for i in vec![52, 49, 21] {
        println!("I like the number {}", i);
    }
}
```

åˆ‡ç‰‡ä¹Ÿå¯ä»¥ä½¿ç”¨ `for in` éå†ï¼š
```rust
fn main() {
    for i in &[52, 49, 21] {
        println!("I like the number {}", i);
    }
}

// è¾“å‡ºï¼š
// I like the number 52
// I like the number 49
// I like the number 21
```

æˆ–è€…ä¸€ä¸ªè¿­ä»£å™¨ï¼š
```rust
fn main() {
    // æ³¨æ„ï¼š&str ç±»å‹ä¹Ÿå¯ä»¥ä½¿ç”¨ .bytes() è¿­ä»£å™¨ã€‚Rust çš„ char ç±»å‹å¤§å°ä¸º 4 ä¸ªå­—èŠ‚ï¼Œä»£è¡¨ Unicode æ ‡é‡å€¼ã€‚
    for c in "rust".chars() {
        println!("Give me a {}", c);
    }
}

// è¾“å‡ºï¼š
// Give me a r
// Give me a u
// Give me a s
// Give me a t
```

å³ä½¿å¯è¿­ä»£çš„å˜é‡ä½¿ç”¨ filter è¿‡æ»¤æˆ–æ˜¯ä½¿ç”¨ flatten éå†ï¼Œä¾ç„¶å¯ä»¥ä½¿ç”¨ `for in`ï¼š
> PSï¼šè¿™é‡Œéœ€è¦è‡ªå·±å»äº†è§£`è¿­ä»£å™¨é€‚é…å™¨`å’Œ`æ¶ˆè´¹è€…é€‚é…å™¨`ã€‚
```rust
fn main() {
    for c in "SuRPRISE INbOUND"
        .chars()
        .filter(|c| c.is_lowercase())
        .flat_map(|c| c.to_uppercase())
    {
        print!("{}", c);
    }
    println!();
}

// è¾“å‡ºï¼šUB
```

ä½ å¯ä»¥ä»å‡½æ•°ä¸­è¿”å›ä¸€ä¸ªé—­åŒ…ï¼š
```rust
fn make_tester(answer: String) -> impl Fn(&str) -> bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    // .into() ä¸ºå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå°† &'static str è½¬æ¢ä¸º String ç±»å‹
    let test = make_tester("hunter2".into());
    println!("{}", test("******"));
    println!("{}", test("hunter2"));
}
// è¾“å‡ºï¼š
// false
// true
```

è¿˜å¯ä»¥å°†å¼•ç”¨ç§»åŠ¨åˆ°è¿”å›çš„é—­åŒ…ä¸­ï¼š
```rust
fn make_tester<'a>(answer: &'a str) -> impl Fn(&'a str) -> bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    let test = make_tester("hunter2");
    println!("{}", test("******"));
    println!("{}", test("hunter2"));
}

// è¾“å‡ºï¼š
// false
// true
```

æ¶ˆé™¤é—­åŒ…ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè®©å‡½æ•°çœ‹èµ·æ¥æ›´ç®€æ´ï¼š
```rust
fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {
    move |challenge| {
        challenge == answer
    }
}
```
ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»èŠ±è´¹äº†åŠå°æ—¶æ¥é˜…è¯»ä¸Šé¢çš„ä»£ç ç‰‡æ®µï¼Œä½ åº”è¯¥èƒ½å¤Ÿé˜…è¯»ç½‘ä¸Šå¤§éƒ¨åˆ†çš„ Rust ä»£ç ã€‚

åœ¨ç¼–å†™ Rust ä»£ç æ—¶ï¼ŒRust çš„ç¼–è¯‘å™¨çš„æç¤ºä¼šå¾ˆæœ‰å¸®åŠ©ã€‚æ¯”å¦‚ä¸Šé¢æ•…æ„å†™é”™çš„ä»£ç ï¼Œrustc æ€»æ˜¯ä¼šæä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæœ‰è§åœ°çš„å»ºè®®ã€‚å¦‚æœç¼–è¯‘å™¨ç¼ºå°‘å¿…è¦çš„æç¤ºï¼Œç¼–è¯‘å™¨å›¢é˜Ÿä¼šç§¯æçš„æ·»åŠ ã€‚

å¦‚éœ€æ›´å¤šçš„ Rust å­¦ä¹ èµ„æ–™ï¼Œä½ å¯ä»¥çœ‹çœ‹ä¸‹é¢è¿™äº›å†…å®¹ï¼š
- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust By Example](https://doc.rust-lang.org/stable/rust-by-example/)
- [Read Rust](https://readrust.net/)
- [This Week In Rust](https://this-week-in-rust.org/)

æˆ‘å†™äº†å…³äº Rust çš„[åšå®¢](https://fasterthanli.me/tags/rust)å’Œ[æ¨æ–‡](https://twitter.com/fasterthanlime)ï¼Œå¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œæ¬¢è¿ç‚¹èµè½¬å‘ã€‚

Have fun!