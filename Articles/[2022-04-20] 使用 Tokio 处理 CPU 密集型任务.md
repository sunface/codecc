> åŸæ–‡é“¾æ¥ï¼šhttps://thenewstack.io/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks/
>
> **ç¿»è¯‘ï¼š[trdthg](https://github.com/trdthg)**
>
> é€‰é¢˜ï¼š[Akagi201](https://github.com/Akagi201)
>
> æœ¬æ–‡ç”± [Rustt](https://Rustt.org) ç¿»è¯‘ï¼Œ[StudyRust](https://studyrust.org) è£èª‰æ¨å‡º

# ä½¿ç”¨ Tokio å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡

å°½ç®¡ async é€šå¸¸éƒ½è¢«åº”ç”¨äºå¼‚æ­¥ç½‘ç»œ I/Oï¼Œä½†æ˜¯åœ¨è¿™ç¯‡æ–‡ç« é‡Œï¼Œæˆ‘ä¼šåƒä½ ä»‹ç»ä¸ºä»€ä¹ˆä½¿ç”¨ Tokio å¤„ç† CPU
å¯†é›†å‹ä»»åŠ¡ï¼ˆæ¯”å¦‚æ•°æ®åˆ†æå¼•æ“ç­‰ï¼‰ä¹Ÿæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚

## Tokio æ˜¯ä»€ä¹ˆï¼Ÿ

Rust æœ¬èº«æä¾›äº†ä¸€ä¸ªç±»ä¼¼äº JavaScript çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ã€‚

ä¸ºäº†å……åˆ†åˆ©ç”¨å¤šæ ¸å’Œå¼‚æ­¥ I/Oã€‚ä¸€ä¸ªè¿è¡Œæ—¶æ˜¯å¿…é¡»çš„ï¼Œå°½ç®¡ç¤¾åŒºæœ‰å¾ˆå¤šå¼‚æ­¥è¿è¡Œæ—¶çš„é€‰æ‹©ï¼Œä½†æ˜¯ Tokio æ˜¯äº‹å®ä¸Šçš„æ ‡å‡†ã€‚å°½ç®¡ Tokio åœ¨å®˜ç½‘ä¸Šæè¿°åˆ°å®ƒæ˜¯
Rust è¯­è¨€çš„ä¸€ä¸ªå¼‚æ­¥è¿è¡Œæ—¶ï¼Œå¹¶ä¸”æä¾›äº†ç¼–å†™ç½‘ç»œæœåŠ¡æ‰€éœ€è¦çš„æ¨¡å—ï¼Œå®ƒä¹Ÿå¯ä»¥è¢«ç”¨åœ¨å…¶å®ƒåœºæ™¯ã€‚

## ä¸ºä»€ä¹ˆä½¿ç”¨ Tokio å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡

ç°ä»£åŒ–çš„æ•°æ®åˆ†æå¼•æ“æ€»æ˜¯ä¸å¯é¿å…çš„è¦å¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„ç½‘ç»œè¯·æ±‚ï¼Œä»¥åŠé€šè¿‡ç½‘ç»œå’Œå¯¹è±¡å­˜å‚¨ç³»ç»Ÿï¼ˆæ¯”å¦‚ ASW S3ã€GCP Cloudã€Azure
ç­‰ï¼‰è¿›è¡Œé€šä¿¡ã€‚å› æ­¤ï¼Œä»»ä½•ä½¿ç”¨ Rust å®ç°çš„ç³»ç»Ÿï¼Œå¤§å¤šéƒ½ä¼šç”¨ Tokio å»å¤„ç†è¿™éƒ¨åˆ†ç½‘ç»œç›¸å…³çš„æœåŠ¡ï¼Œæˆ–è€…æ˜¯ä¸€éƒ¨åˆ†æ–‡ä»¶ I/O æœåŠ¡ã€‚

é™¤äº†åº”å¯¹ç½‘ç»œå¤–ï¼Œæ•°æ®åˆ†æå¼•æ“è¿˜éœ€è¦åšå¤§é‡ç¹é‡çš„çš„ CPU è®¡ç®—ï¼Œæ¶ˆè€—å¤§é‡ CPU
èµ„æºå»è¿›è¡Œè¯¸å¦‚ï¼šé‡æ–°ç»„ç»‡æ•°æ®å­˜å‚¨ã€æå‰è®¡ç®—å„ç§ç´¢å¼•ã€æˆ–è€…æ˜¯ç›´æ¥å›å¤å®¢æˆ·ç«¯è¯·æ±‚ç­‰å·¥ä½œã€‚è¿™äº›å¤æ‚è®¡ç®—é€šå¸¸ä¼šè¢«åˆ‡æˆè®¸å¤šå•ç‹¬çš„å—ï¼ˆæˆ‘æŠŠå®ƒä»¬ç§°ä¸º
"ä»»åŠ¡"ï¼‰ï¼Œç„¶åè¢«å¹¶è¡Œçš„å¤„ç†ï¼Œä»¥åˆ©ç”¨åˆ°ç°ä»£ CPU çš„å¤šæ ¸ç‰¹æ€§ã€‚

ä»»åŠ¡è°ƒåº¦å™¨ä¼šå†³å®šå“ªä¸ªä»»åŠ¡åº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™è¿è¡Œï¼Œå®ƒä¼šå°†ä»»åŠ¡æ˜ å°„åˆ°åˆé€‚çš„ CPU å†…æ ¸æˆ–è€…æ˜¯çº¿ç¨‹ä¸Šã€‚

å­¦æœ¯ç•Œå’Œå·¥ä¸šç•Œå¯¹äºå„ç§ä»»åŠ¡è°ƒåº¦å™¨ã€å·¥ä½œæ± ã€çº¿ç¨‹æ± ç­‰å·²ç»ç§¯ç´¯äº†å¾ˆå¤šå¹´çš„ç ”ç©¶ã€‚

æˆ‘è‡ªå·±å·²ç»å®ç°å¹¶ä¸”ä½¿ç”¨è¿‡å‡ ä¸ªè‡ªå®šä¹‰çš„ä»»åŠ¡è°ƒåº¦å™¨ã€‚ä»–ä»¬åœ¨å¤§å¤šæ•°æ—¶é—´ (99.9%)
éƒ½å·¥ä½œçš„å¾ˆå¥½ï¼Œä½†æ˜¯åœ¨å¤„ç†è¾¹ç¼˜æƒ…å†µï¼ˆæ¯”å¦‚å¿«é€Ÿåœæœºã€ä»»åŠ¡å–æ¶ˆã€æ¸…ç†ç­‰ï¼‰æ—¶ï¼Œä»–ä»¬çš„æ•ˆæœéå¸¸ä¸å°½äººæ„ã€‚ç”±äºè¿™äº›ä»»åŠ¡è°ƒåº¦å™¨ä½¿ç”¨äº†è¾ƒä½çº§åˆ«çš„çº¿ç¨‹åŸè¯­ï¼Œå‡ºç°çº¿ç¨‹é—´ç«äº‰çš„æƒ…å†µæ¯”æ¯”çš†æ˜¯ï¼Œæ‰€ä»¥æˆ‘ä¸å»ºè®®è¿™æ ·åšã€‚

å› æ­¤ï¼Œå½“æˆ‘åœ¨ Rust ç”Ÿæ€ä¸­å¯»æ‰¾ä¸€ä¸ªä»»åŠ¡è°ƒåº¦å™¨æ—¶ï¼Œä½ ä¼šå¾ˆè‡ªç„¶çš„é€‰æ‹© Tokioã€‚Tokio æœ‰å¾ˆå¤šä¼˜åŠ¿ï¼š

1. ä½ åªéœ€è¦ Tokioï¼Œå¹¶ä¸éœ€è¦æ·»åŠ å…¶ä»–ä¾èµ–é¡¹ã€‚
2. Tokio å®ç°äº†ä¸€ä¸ªå¤æ‚çš„ [æ”¯æŒä»»åŠ¡çªƒå–çš„è°ƒåº¦å™¨](https://tokio.rs/blog/2019-10-scheduler)ã€‚
3. Tokio å†…éƒ¨å®ç°äº†å¯¹ async/await çš„æ”¯æŒã€‚å¹¶ä¸”æœ‰è®¸å¤šç›¸å¯¹æˆç†Ÿçš„åº“å»å¤„ç†æµã€å¼‚æ­¥é”ã€ç®¡é“ã€å¼‚æ­¥å–æ¶ˆç­‰ã€‚
4. Tokio åœ¨ Rust ç”Ÿæ€ç³»ç»Ÿä¸­ç»è¿‡äº†è‰¯å¥½æµ‹è¯•ï¼Œå¹¶ä¸”æœ‰ç€å¤§é‡ä½¿ç”¨æ¡ˆä¾‹ã€‚
5. Tokio é€šå¸¸ä¼šå°†æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡å’Œ `Future` æ”¾åœ¨åŒä¸€ä¸ªæ‰§è¡Œå™¨å†…ï¼Œè¿™æœ‰åˆ©äºå®ç°å±€éƒ¨ç¼“å­˜ã€‚
6. Tokio çš„ [æ–‡æ¡£](https://tokio.rs/tokio/tutorial) å¾ˆå®Œå–„ï¼Œå¹¶ä¸”åœ¨ç§¯ææ›´æ–°ç»´æŠ¤ã€‚

å› æ­¤ï¼Œé€‰æ‹© Tokio ä½œä¸º CPU å¯†é›†å‹ä»»åŠ¡çš„ä»»åŠ¡è°ƒåº¦ç¨‹åºæ˜¯ç†æ‰€åº”å½“çš„ï¼Œå¯¹å§ï¼ŸWROOOOOOOONGï¼

## ä½¿ç”¨ Tokio çš„åå¯¹æ„è§

é€‰æ‹© Tokio åœ¨æˆ‘ä»¬å›¢é˜Ÿä¸­å˜æˆäº†ä¸€ä¸ªçƒ­é—¨è¯é¢˜ï¼Œåˆ°ç°åœ¨ä¾ç„¶ä¸æ˜¯æ‰€æœ‰äººéƒ½è®¤å¯è¿™ä¸ªå†³å®šã€‚åœ¨æˆ‘ä»¬åš DataFusion å’Œ InfluxDB IOx
çš„æ—©æœŸï¼Œæˆ‘ä»¬å¾ˆæ‹…å¿ƒè¿™ä¸ªé—®é¢˜ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›åå¯¹æ„è§ï¼š

### Tokio æ–‡æ¡£çš„è­¦å‘Šï¼š

è€ç‰ˆæœ¬çš„ Tokio æ–‡æ¡£ï¼ˆæ¯”å¦‚ 1.10 ç‰ˆï¼‰é‡Œé¢æœ‰ä¸€æ¡è‘—åçš„è­¦å‘Šï¼š

> If your code is CPU-bound and you wish to limit the number of threads used to
> run it, you should run it on another thread pool such as Rayon.

å¦‚æœä½ çš„ä»£ç è¦å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡ï¼Œå¹¶ä¸”æƒ³è¦å°½é‡å‡å°‘ä½¿ç”¨åˆ°çš„çº¿ç¨‹æ•°ï¼Œä½ åº”è¯¥å°†è¿™äº›ä»»åŠ¡åˆ†é…åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ± æ¯”å¦‚ Rayonã€‚

è¿™ä¸ªè­¦å‘Šå¯¹æˆ‘ä»¬å›¢é˜Ÿå’Œç¤¾åŒºéƒ½é€ æˆäº†å¾ˆå¤§çš„å›°æƒ‘ã€‚å¾ˆå¤šäººè¯»äº†ä¹‹åéƒ½ä»¥ä¸º Tokio æ°¸è¿œä¸åº”è¯¥ç”¨æ¥å¤„ç† CPU
å¯†é›†å‹ä»»åŠ¡ã€‚ä½†æ˜¯æ–‡æ¡£çš„å…³é”®å…¶å®æ˜¯è¯´ï¼Œä¸€ä¸ªè¿è¡Œæ—¶å®ä¾‹ï¼ˆåŒä¸€ä¸ªçº¿ç¨‹æ± ï¼‰ä¸åº”è¯¥åŒæ—¶ç”¨äº I/O å’Œ CPU
è®¡ç®—ï¼Œæˆ‘ä»¬ä¹‹åæ¾„æ¸…äº†[æ–‡æ¡£](https://docs.rs/tokio/1.14.0/tokio/#cpu-bound-tasks-and-blocking-code)
çš„æ„å›¾ã€‚

> é¡ºä¾¿è¯´ä¸€å¥ï¼ŒTokio æ–‡æ¡£å»ºè®®ç”¨ Rayon å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡ã€‚Rayon
> å¯¹äºå¾ˆå¤šç¨‹åºéƒ½æ˜¯å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œä½†æ˜¯å®ƒå¹¶ä¸æ”¯æŒå¼‚æ­¥ã€‚å¦‚æœä½ çš„ä»£ç ä¸­å“ªæ€•åªæœ‰ä¸€ç‚¹éœ€è¦ä½¿ç”¨å¼‚æ­¥ï¼Œé‚£ä½ å°±ä¸å¾—ä¸è·¨è¿‡åŒæ­¥å’Œå¼‚æ­¥çš„ç—›è‹¦è¾¹ç•Œã€‚æˆ‘è¿˜å‘ç°å®ç°ä¸€ä¸ª
> [åŸºäºæ‹‰å–çš„æ‰§è¡Œå™¨æ¨¡å‹](http://justinjaffray.com/query-engines-push-vs.-pull/)
> ä¼šæ›´å›°éš¾ï¼Œè¿™ç§æ¨¡å‹è¦æ±‚æŸä¸ªä»»åŠ¡å¿…é¡»ç­‰å¾…æ‰€æœ‰çš„è¾“å…¥éƒ½å‡†å¤‡å¥½åœ¨èƒ½åœ¨ Rayon ä¸­è¿è¡Œ

### å°¾éƒ¨å»¶è¿Ÿä¼šæ‹–ç´¯ä½ 

èªæ˜çš„äººä¼šè¯´ï¼šä½¿ç”¨ Tokio å¤„ç† CPU
å¯†é›†å‹ä»»åŠ¡ä¼šå¢åŠ è¯·æ±‚çš„[å°¾éƒ¨å»¶è¿Ÿ](https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577)ï¼Œè¿™æ˜¯éš¾ä»¥ä»¤äººæ¥å—çš„ã€‚

å°¾éƒ¨å»¶è¿Ÿï¼ŸğŸ™„

ä½ å¯èƒ½è®¤ä¸ºï¼šæˆ‘æ­£åœ¨ç¼–å†™ä¸€ä¸ªæ•°æ®åº“ï¼Œå°¾éƒ¨å»¶è¿Ÿå¬èµ·æ¥åƒæ˜¯å¯¹äºé«˜è´Ÿè½½çš„ Web æœåŠ¡å™¨çš„ä¸€ä¸ªå­¦æœ¯é—®é¢˜â€¦â€¦â€

ä½†å…¶å®ï¼Œè¿™ä¹Ÿæ˜¯éœ€è¦è€ƒè™‘çš„ï¼šæ€è€ƒä¸€ä¸‹å¥åº·æ£€æŸ¥ï¼Œå¥åº·æ£€æŸ¥å¯¹äºä½¿ç”¨å®¹å™¨ç¼–æ’ç³»ç»Ÿï¼ˆæ¯”å¦‚ Kubernetesï¼‰éƒ¨ç½²çš„æœåŠ¡æ˜¯å¿…ä¸å¯å°‘çš„ã€‚æ£€æŸ¥çš„æ–¹å¼é€šå¸¸æ˜¯å‘é€ä¸€ä¸ª HTTP
è¯·æ±‚åˆ°æŸä¸ª API ï¼Œä¾‹å¦‚ `/health`ã€‚å¦‚æœè¯¥è¯·æ±‚å·²ç»è¢«åˆ†æ´¾åˆ°æŸä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œä½†æ˜¯ Tokio æ­£åœ¨å¿™äºä½¿ç”¨ CPU è¿›è¡Œå¤§é‡æ•°æ®å¤„ç†ä»»åŠ¡ï¼Œé‚£ä¹ˆ
Kubernetes å°†ä¸èƒ½åŠæ—¶å¾—åˆ° â€œç³»ç»Ÿæ­£å¸¸â€ çš„å“åº”ï¼Œä½ çš„è¿›ç¨‹å°±ä¼šè¢« K8s æ€æ­»ã€‚å› æ­¤å¾—åˆ°ç»“è®ºï¼šç”±äºå°¾éƒ¨å»¶è¿Ÿï¼Œä½ ä¸èƒ½å°† Tokio ç”¨äº CPU
å¯†é›†å‹ä»»åŠ¡ã€‚

ä½†æ˜¯ï¼Œå°±åƒ Tokio åœ¨æ–‡æ¡£ä¸­é˜è¿°çš„ï¼Œæƒ³è¦é˜²æ­¢ä½ çš„ç¨‹åºåœ¨ CPU å®Œå…¨é¥±å’Œçš„æƒ…å†µä¸‹è¢« K8s
è¯¯æ€ï¼Œä½ åº”è¯¥ä½¿ç”¨ä¸¤ä¸ªç‹¬ç«‹çš„çº¿ç¨‹æ± ã€‚ä¸€ä¸ªç”¨æ¥æ‰§è¡Œå¯¹å°¾éƒ¨å»¶è¿Ÿæ•æ„Ÿçš„ä»»åŠ¡ï¼Œå°±æ¯”å¦‚å“åº” `/health` æ¥å£ã€‚å¦ä¸€ä¸ªç”¨æ¥æ‰§è¡Œ CPU
å¯†é›†å‹ä»»åŠ¡ã€‚è¿™äº›çº¿ç¨‹æ± çš„çš„æœ€ä½³çº¿ç¨‹æ•°éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚å»è°ƒæ•´ã€‚

å¦‚æœä½ å°† Tokio è¿è¡Œæ—¶åªæ˜¯è§†ä¸ºä¸€ä¸ªå¤æ‚ç‚¹çš„çº¿ç¨‹æ± ï¼Œé‚£ä¹ˆä½¿ç”¨å¤šä¸ªè¿è¡Œæ—¶å®ä¾‹çš„æƒ³æ³•å¯èƒ½æ›´å®¹æ˜“æ¥å—ï¼Œæˆ‘ä»¬å°†åœ¨æœ€åä½¿ç”¨ä¸“ç”¨çš„æ‰§è¡Œå™¨æ¼”ç¤ºå¦‚ä½•å®ç°è¿™ä¸ªæƒ³æ³•ã€‚

### å•ä»»åŠ¡å¼€é”€å¾ˆé«˜

Tokio çš„æ¯ä¸ªä»»åŠ¡å¼€é”€å¾ˆé«˜ã€‚

å¯¹äºè¿™ç‚¹ï¼Œæˆ‘ä¸€ç‚¹ä¹Ÿä¸æƒŠè®¶ã€‚äººä»¬æ€»æ˜¯å¯ä»¥å®ç°æ¯” Tokio è¿è¡Œé€Ÿåº¦æ›´å¿«çš„çº¿ç¨‹æ± ã€‚ä½†æ˜¯ï¼Œè¿™äº›çº¿ç¨‹æ± å¹¶ä¸æ˜¯è¶³å¤Ÿç¨³å®šï¼Œéš¾ä»¥åº”å¯¹ç”Ÿäº§ç¯å¢ƒçš„è´Ÿè½½ï¼Œå¹¶ä¸”ä»–ä»¬ä¹Ÿä¸å…·å¤‡åƒ
Tokio ä¸€æ ·çš„åºå¤§ç”Ÿæ€ç³»ç»Ÿã€‚

åœ¨è®¸å¤šåœºæ™¯ä¸‹ï¼Œå•ä»»åŠ¡çš„å¼€é”€å¯ä»¥ä½¿ç”¨ â€œçŸ¢é‡åŒ–å¤„ç†â€
æ¥åˆ†æ‘Šã€‚æ„æ€æ˜¯æ¯ä¸ªä»»åŠ¡å›åŒæ—¶å¤„ç†å‡ åƒè¡Œæ•°æ®è€Œä¸æ˜¯å•å•ä¸€è¡Œï¼Œä½ éœ€è¦å°†ä»»åŠ¡åˆ†æˆåˆç†å¤§å°çš„å—ã€‚ä½ ä¹Ÿä¸èƒ½åˆ†æ‘Šæ‰€æœ‰å·¥ä½œåœºæ™¯ä¸‹çš„å¼€é”€ã€‚ä½†æ˜¯ï¼Œå¯¹äºæˆ‘ä»¬çš„ç¨‹åºå…³å¿ƒçš„å®ä¾‹æ¥è¯´ï¼ŒTokio
çš„ä»»åŠ¡å¼€é”€å·²ç»å¾®ä¹å…¶å¾®äº†

## å®è·µ

å‡è®¾ä½ å·²ç»è¢«è¯´æœäº†ä½¿ç”¨ Tokio å»å¤„ç† CPU å¯†é›†å‹ä»»åŠ¡æ˜¯å¯è¡Œçš„ã€‚ç°åœ¨ä½ åº”è¯¥æ€ä¹ˆåšï¼Ÿ

é¦–å…ˆï¼Œè‡³å…³é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼Œä½ çš„ä»£ç åº”è¯¥ç¬¦åˆä»¥ä¸‹åŸåˆ™ï¼šå¼‚æ­¥ä»£ç æ°¸è¿œä¸åº”è¯¥èŠ±è´¹å¾ˆé•¿æ—¶é—´æ‰èƒ½å®Œæˆï¼Œè¿™ä¸€ç‚¹è¯·å‚è€ƒ Alice Ryhl çš„
[Async: What is blocking?](https://ryhl.io/blog/async-what-is-blocking/)ã€‚è¿™æ˜¯ä¸ºäº†è®©è°ƒåº¦å™¨æœ‰æœºä¼šå®‰æ’å…¶ä»–äº‹æƒ…ï¼Œæ¯”å¦‚ä»»åŠ¡çªƒå–ç­‰ã€‚

å½“ç„¶äº†ï¼Œè¿™ä¸ª â€œå¾ˆé•¿æ—¶é—´â€ å–å†³äºä½ çš„ç¨‹åºï¼›Ryhl å»ºè®®åœ¨ä¼˜åŒ–å“åº”çš„å°¾éƒ¨å»¶è¿Ÿæ—¶ï¼Œå•ä¸ªå¼‚æ­¥ä»»åŠ¡å®Œæˆæ—¶é—´åº”è¯¥åœ¨ 10 ~ 100 å¾®ç§’ã€‚æˆ‘è®¤ä¸ºåœ¨é’ˆå¯¹ CPU
è¿›è¡Œä¼˜åŒ–æ—¶ 10~100 æ¯«ç§’ä¹Ÿèƒ½æœ‰ä¸é”™çš„æ•ˆæœã€‚ä½†æ˜¯åœ¨æˆ‘çš„æµ‹è¯•
[estimated per-task Tokio overhead](https://github.com/alamb/rust_tokio_overhead)
ä¸­ï¼ŒTokio å•ä»»åŠ¡çš„å¼€é”€åœ¨çº¦ 10 çº³ç§’èŒƒå›´å†…ï¼Œå› æ­¤å‡ ä¹ä¸å¯èƒ½ç”¨ 10 æ¯«ç§’çš„ä»»åŠ¡æ¥æµ‹é‡ Tokio è¿è¡Œæ—¶å¼€é”€ã€‚

å…¶æ¬¡ï¼Œå°†ä»»åŠ¡åˆ†æ´¾åˆ°ä¸€ä¸ªå•ç‹¬çš„æ‰§è¡Œå™¨

### ä¸“ç”¨çš„æ‰§è¡Œå™¨

è¿™é‡Œæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œæ¼”ç¤ºäº†æˆ‘ä»¬å¦‚ä½•åœ¨ InfluxDB IOx ä¸Šå°†ä»»åŠ¡åˆ†é…åˆ°ä¸€ä¸ªå•ç‹¬çš„ Tokio
è¿è¡Œæ—¶ä¸Šï¼ˆå®Œæ•´ä»£ç å¯ä»¥åœ¨æˆ‘ä»¬çš„[ä»“åº“](https://github.com/influxdata/influxdb_iox/blob/fe155e15fb2ad166aee66b0458e63c24a8128dd4/query/src/exec/task.rs#L101-L118)é‡ŒæŸ¥çœ‹ï¼Œé‡Œé¢è¿˜æœ‰å…³äºæ¸…ç†ã€åœæœºã€åˆå¹¶çš„å†…å®¹ï¼‰

```rs
pub struct DedicatedExecutor {
    state: Arc<Mutex<State>>,
}

/// Runs futures (and any `tasks` that are `tokio::task::spawned` by
/// them) on a separate Tokio Executor
struct State {
    /// Channel for requests -- the dedicated executor takes requests
    /// from here and runs them.
    requests: Option<std::sync::mpsc::Sender<Task>>,

    /// Thread which has a different Tokio runtime
    /// installed and spawns tasks there
    thread: Option<std::thread::JoinHandle<()>>,
}

impl DedicatedExecutor {
    /// Creates a new `DedicatedExecutor` with a dedicated Tokio
    /// executor that is separate from the threadpool created via
    /// `[tokio::main]`.
    pub fn new(thread_name: &str, num_threads: usize) -> Self {
        let thread_name = thread_name.to_string();

        let (tx, rx) = std::sync::mpsc::channel::<Task>();

        let thread = std::thread::spawn(move || {
            // Create a new Runtime to run tasks
            let runtime = Tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .thread_name(&thread_name)
                .worker_threads(num_threads)
                // Lower OS priority of worker threads to prioritize main runtime
                .on_thread_start(move || set_current_thread_priority_low())
                .build()
                .expect("Creating Tokio runtime");

         // Pull task requests off the channel and send them to the executor
         runtime.block_on(async move {
                while let Ok(task) = rx.recv() {
                    Tokio::task::spawn(async move {
                        task.run().await;
                    });
                }

        let state = State {
            requests: Some(tx),
            thread: Some(thread),
        };

        Self {
            state: Arc::new(Mutex::new(state)),
        }
    }
```

è¿™æ®µä»£ç ä¼šåœ¨ä¸€ä¸ªæ–°çº¿ç¨‹ `std::thread`ï¼Œå¹¶åœ¨è¿™ä¸ªçº¿ç¨‹é‡Œåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ Tokio è¿è¡Œæ—¶ã€‚è¿è¡Œæ—¶ä¼šä» `channel` è·å–ä»»åŠ¡å¹¶è¿è¡Œã€‚

æ³¨æ„ï¼šè¿™ä¸ªæ–°çš„çº¿ç¨‹å¾ˆå…³é”®ï¼Œå¦‚æœä½ å°è¯•åœ¨ä¸»çº¿ç¨‹é‡Œæˆ–è€…æ˜¯ä»»ä½•å·²ç»åˆ›å»ºè¿‡ Tokio è¿è¡Œæ—¶çš„çº¿ç¨‹é‡Œå†æ¬¡åˆ›å»ºæ–°çš„è¿è¡Œæ—¶ï¼Œç¨‹åºå°±ä¼šæŠ¥é”™ï¼Œå› ä¸ºå·²ç»æœ‰ä¸€ä¸ªè¿è¡Œæ—¶äº†ã€‚

ä¸‹é¢çš„ä»£ç å°†ä»»åŠ¡åˆ†æ´¾åˆ°ç¬¬äºŒä¸ªè¿è¡Œæ—¶ã€‚

```rs
impl DedicatedExecutor {

    /// Runs the specified Future (and any tasks it spawns) on the
    /// `DedicatedExecutor`.
    pub fn spawn<T>(&self, task: T) -> Job<T::Output>
    where
        T: Future + Send + 'static,
        T::Output: Send + 'static,
    {
        let (tx, rx) = tokio::sync::oneshot::channel();

        let fut = Box::pin(async move {
            let task_output = task.await;
            tx.send(task_output).ok()
        });
        let mut state = self.state.lock();
        let task = Task {
            fut,
        };

        if let Some(requests) = &mut state.requests {
            // would fail if someone has started shutdown
            requests.send(task).ok();
        } else {
            warn!("tried to schedule task on an executor that was shutdown");
        }

        Job { rx, cancel }
    }
}
```

ä¸Šé¢çš„ä»£ç ä½¿ç”¨äº†ä¸€ä¸ªåä¸º Job çš„ç»“æ„ä½“ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯¹ Future çš„ç®€å•åŒ…è£…ï¼ŒJob èƒ½å¤Ÿå°† Future
çš„æ‰§è¡Œç»“æœä»å•ç‹¬çš„æ‰§è¡Œå™¨å†…ä¼ è¾“å›ä¸»çº¿ç¨‹ã€‚ç›¸å…³ä»£ç å¦‚ä¸‹ã€‚

```rs
#[pin_project(PinnedDrop)]
pub struct Job<T> {
    #[pin]
    rx: Receiver<T>,
}

impl<T> Future for Job<T> {
    type Output = Result<T, Error>;

    fn poll(
        self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.rx.poll(cx)
    }
}
```

å°±æ˜¯è¿™æ ·ï¼ ä½ å¯ä»¥åœ¨
[Github gist](https://gist.github.com/alamb/bd0e086448ef9b438aeebd6f550e23ed)
ä¸­æ‰¾åˆ°æ‰€æœ‰ä»£ç ã€‚
